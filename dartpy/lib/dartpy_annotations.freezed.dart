// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'dartpy_annotations.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$PyTypeAnnotation {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() pyint,
    required TResult Function() pydouble,
    required TResult Function(List<PyTypeAnnotation> elements) pytuple,
    required TResult Function(PyTypeAnnotation listType) pylist,
    required TResult Function(
            PyTypeAnnotation keyType, PyTypeAnnotation valueType)
        pymap,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? pyint,
    TResult? Function()? pydouble,
    TResult? Function(List<PyTypeAnnotation> elements)? pytuple,
    TResult? Function(PyTypeAnnotation listType)? pylist,
    TResult? Function(PyTypeAnnotation keyType, PyTypeAnnotation valueType)?
        pymap,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? pyint,
    TResult Function()? pydouble,
    TResult Function(List<PyTypeAnnotation> elements)? pytuple,
    TResult Function(PyTypeAnnotation listType)? pylist,
    TResult Function(PyTypeAnnotation keyType, PyTypeAnnotation valueType)?
        pymap,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PyInt value) pyint,
    required TResult Function(PyDouble value) pydouble,
    required TResult Function(PyTuple value) pytuple,
    required TResult Function(PyList value) pylist,
    required TResult Function(PyMap value) pymap,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PyInt value)? pyint,
    TResult? Function(PyDouble value)? pydouble,
    TResult? Function(PyTuple value)? pytuple,
    TResult? Function(PyList value)? pylist,
    TResult? Function(PyMap value)? pymap,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PyInt value)? pyint,
    TResult Function(PyDouble value)? pydouble,
    TResult Function(PyTuple value)? pytuple,
    TResult Function(PyList value)? pylist,
    TResult Function(PyMap value)? pymap,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PyTypeAnnotationCopyWith<$Res> {
  factory $PyTypeAnnotationCopyWith(
          PyTypeAnnotation value, $Res Function(PyTypeAnnotation) then) =
      _$PyTypeAnnotationCopyWithImpl<$Res, PyTypeAnnotation>;
}

/// @nodoc
class _$PyTypeAnnotationCopyWithImpl<$Res, $Val extends PyTypeAnnotation>
    implements $PyTypeAnnotationCopyWith<$Res> {
  _$PyTypeAnnotationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$PyIntImplCopyWith<$Res> {
  factory _$$PyIntImplCopyWith(
          _$PyIntImpl value, $Res Function(_$PyIntImpl) then) =
      __$$PyIntImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PyIntImplCopyWithImpl<$Res>
    extends _$PyTypeAnnotationCopyWithImpl<$Res, _$PyIntImpl>
    implements _$$PyIntImplCopyWith<$Res> {
  __$$PyIntImplCopyWithImpl(
      _$PyIntImpl _value, $Res Function(_$PyIntImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PyIntImpl implements PyInt {
  const _$PyIntImpl();

  @override
  String toString() {
    return 'PyTypeAnnotation.pyint()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PyIntImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() pyint,
    required TResult Function() pydouble,
    required TResult Function(List<PyTypeAnnotation> elements) pytuple,
    required TResult Function(PyTypeAnnotation listType) pylist,
    required TResult Function(
            PyTypeAnnotation keyType, PyTypeAnnotation valueType)
        pymap,
  }) {
    return pyint();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? pyint,
    TResult? Function()? pydouble,
    TResult? Function(List<PyTypeAnnotation> elements)? pytuple,
    TResult? Function(PyTypeAnnotation listType)? pylist,
    TResult? Function(PyTypeAnnotation keyType, PyTypeAnnotation valueType)?
        pymap,
  }) {
    return pyint?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? pyint,
    TResult Function()? pydouble,
    TResult Function(List<PyTypeAnnotation> elements)? pytuple,
    TResult Function(PyTypeAnnotation listType)? pylist,
    TResult Function(PyTypeAnnotation keyType, PyTypeAnnotation valueType)?
        pymap,
    required TResult orElse(),
  }) {
    if (pyint != null) {
      return pyint();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PyInt value) pyint,
    required TResult Function(PyDouble value) pydouble,
    required TResult Function(PyTuple value) pytuple,
    required TResult Function(PyList value) pylist,
    required TResult Function(PyMap value) pymap,
  }) {
    return pyint(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PyInt value)? pyint,
    TResult? Function(PyDouble value)? pydouble,
    TResult? Function(PyTuple value)? pytuple,
    TResult? Function(PyList value)? pylist,
    TResult? Function(PyMap value)? pymap,
  }) {
    return pyint?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PyInt value)? pyint,
    TResult Function(PyDouble value)? pydouble,
    TResult Function(PyTuple value)? pytuple,
    TResult Function(PyList value)? pylist,
    TResult Function(PyMap value)? pymap,
    required TResult orElse(),
  }) {
    if (pyint != null) {
      return pyint(this);
    }
    return orElse();
  }
}

abstract class PyInt implements PyTypeAnnotation {
  const factory PyInt() = _$PyIntImpl;
}

/// @nodoc
abstract class _$$PyDoubleImplCopyWith<$Res> {
  factory _$$PyDoubleImplCopyWith(
          _$PyDoubleImpl value, $Res Function(_$PyDoubleImpl) then) =
      __$$PyDoubleImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PyDoubleImplCopyWithImpl<$Res>
    extends _$PyTypeAnnotationCopyWithImpl<$Res, _$PyDoubleImpl>
    implements _$$PyDoubleImplCopyWith<$Res> {
  __$$PyDoubleImplCopyWithImpl(
      _$PyDoubleImpl _value, $Res Function(_$PyDoubleImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PyDoubleImpl implements PyDouble {
  const _$PyDoubleImpl();

  @override
  String toString() {
    return 'PyTypeAnnotation.pydouble()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PyDoubleImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() pyint,
    required TResult Function() pydouble,
    required TResult Function(List<PyTypeAnnotation> elements) pytuple,
    required TResult Function(PyTypeAnnotation listType) pylist,
    required TResult Function(
            PyTypeAnnotation keyType, PyTypeAnnotation valueType)
        pymap,
  }) {
    return pydouble();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? pyint,
    TResult? Function()? pydouble,
    TResult? Function(List<PyTypeAnnotation> elements)? pytuple,
    TResult? Function(PyTypeAnnotation listType)? pylist,
    TResult? Function(PyTypeAnnotation keyType, PyTypeAnnotation valueType)?
        pymap,
  }) {
    return pydouble?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? pyint,
    TResult Function()? pydouble,
    TResult Function(List<PyTypeAnnotation> elements)? pytuple,
    TResult Function(PyTypeAnnotation listType)? pylist,
    TResult Function(PyTypeAnnotation keyType, PyTypeAnnotation valueType)?
        pymap,
    required TResult orElse(),
  }) {
    if (pydouble != null) {
      return pydouble();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PyInt value) pyint,
    required TResult Function(PyDouble value) pydouble,
    required TResult Function(PyTuple value) pytuple,
    required TResult Function(PyList value) pylist,
    required TResult Function(PyMap value) pymap,
  }) {
    return pydouble(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PyInt value)? pyint,
    TResult? Function(PyDouble value)? pydouble,
    TResult? Function(PyTuple value)? pytuple,
    TResult? Function(PyList value)? pylist,
    TResult? Function(PyMap value)? pymap,
  }) {
    return pydouble?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PyInt value)? pyint,
    TResult Function(PyDouble value)? pydouble,
    TResult Function(PyTuple value)? pytuple,
    TResult Function(PyList value)? pylist,
    TResult Function(PyMap value)? pymap,
    required TResult orElse(),
  }) {
    if (pydouble != null) {
      return pydouble(this);
    }
    return orElse();
  }
}

abstract class PyDouble implements PyTypeAnnotation {
  const factory PyDouble() = _$PyDoubleImpl;
}

/// @nodoc
abstract class _$$PyTupleImplCopyWith<$Res> {
  factory _$$PyTupleImplCopyWith(
          _$PyTupleImpl value, $Res Function(_$PyTupleImpl) then) =
      __$$PyTupleImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<PyTypeAnnotation> elements});
}

/// @nodoc
class __$$PyTupleImplCopyWithImpl<$Res>
    extends _$PyTypeAnnotationCopyWithImpl<$Res, _$PyTupleImpl>
    implements _$$PyTupleImplCopyWith<$Res> {
  __$$PyTupleImplCopyWithImpl(
      _$PyTupleImpl _value, $Res Function(_$PyTupleImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? elements = null,
  }) {
    return _then(_$PyTupleImpl(
      null == elements
          ? _value._elements
          : elements // ignore: cast_nullable_to_non_nullable
              as List<PyTypeAnnotation>,
    ));
  }
}

/// @nodoc

class _$PyTupleImpl implements PyTuple {
  const _$PyTupleImpl(final List<PyTypeAnnotation> elements)
      : _elements = elements;

  final List<PyTypeAnnotation> _elements;
  @override
  List<PyTypeAnnotation> get elements {
    if (_elements is EqualUnmodifiableListView) return _elements;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_elements);
  }

  @override
  String toString() {
    return 'PyTypeAnnotation.pytuple(elements: $elements)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PyTupleImpl &&
            const DeepCollectionEquality().equals(other._elements, _elements));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_elements));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PyTupleImplCopyWith<_$PyTupleImpl> get copyWith =>
      __$$PyTupleImplCopyWithImpl<_$PyTupleImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() pyint,
    required TResult Function() pydouble,
    required TResult Function(List<PyTypeAnnotation> elements) pytuple,
    required TResult Function(PyTypeAnnotation listType) pylist,
    required TResult Function(
            PyTypeAnnotation keyType, PyTypeAnnotation valueType)
        pymap,
  }) {
    return pytuple(elements);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? pyint,
    TResult? Function()? pydouble,
    TResult? Function(List<PyTypeAnnotation> elements)? pytuple,
    TResult? Function(PyTypeAnnotation listType)? pylist,
    TResult? Function(PyTypeAnnotation keyType, PyTypeAnnotation valueType)?
        pymap,
  }) {
    return pytuple?.call(elements);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? pyint,
    TResult Function()? pydouble,
    TResult Function(List<PyTypeAnnotation> elements)? pytuple,
    TResult Function(PyTypeAnnotation listType)? pylist,
    TResult Function(PyTypeAnnotation keyType, PyTypeAnnotation valueType)?
        pymap,
    required TResult orElse(),
  }) {
    if (pytuple != null) {
      return pytuple(elements);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PyInt value) pyint,
    required TResult Function(PyDouble value) pydouble,
    required TResult Function(PyTuple value) pytuple,
    required TResult Function(PyList value) pylist,
    required TResult Function(PyMap value) pymap,
  }) {
    return pytuple(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PyInt value)? pyint,
    TResult? Function(PyDouble value)? pydouble,
    TResult? Function(PyTuple value)? pytuple,
    TResult? Function(PyList value)? pylist,
    TResult? Function(PyMap value)? pymap,
  }) {
    return pytuple?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PyInt value)? pyint,
    TResult Function(PyDouble value)? pydouble,
    TResult Function(PyTuple value)? pytuple,
    TResult Function(PyList value)? pylist,
    TResult Function(PyMap value)? pymap,
    required TResult orElse(),
  }) {
    if (pytuple != null) {
      return pytuple(this);
    }
    return orElse();
  }
}

abstract class PyTuple implements PyTypeAnnotation {
  const factory PyTuple(final List<PyTypeAnnotation> elements) = _$PyTupleImpl;

  List<PyTypeAnnotation> get elements;
  @JsonKey(ignore: true)
  _$$PyTupleImplCopyWith<_$PyTupleImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PyListImplCopyWith<$Res> {
  factory _$$PyListImplCopyWith(
          _$PyListImpl value, $Res Function(_$PyListImpl) then) =
      __$$PyListImplCopyWithImpl<$Res>;
  @useResult
  $Res call({PyTypeAnnotation listType});

  $PyTypeAnnotationCopyWith<$Res> get listType;
}

/// @nodoc
class __$$PyListImplCopyWithImpl<$Res>
    extends _$PyTypeAnnotationCopyWithImpl<$Res, _$PyListImpl>
    implements _$$PyListImplCopyWith<$Res> {
  __$$PyListImplCopyWithImpl(
      _$PyListImpl _value, $Res Function(_$PyListImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? listType = null,
  }) {
    return _then(_$PyListImpl(
      null == listType
          ? _value.listType
          : listType // ignore: cast_nullable_to_non_nullable
              as PyTypeAnnotation,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $PyTypeAnnotationCopyWith<$Res> get listType {
    return $PyTypeAnnotationCopyWith<$Res>(_value.listType, (value) {
      return _then(_value.copyWith(listType: value));
    });
  }
}

/// @nodoc

class _$PyListImpl implements PyList {
  const _$PyListImpl(this.listType);

  @override
  final PyTypeAnnotation listType;

  @override
  String toString() {
    return 'PyTypeAnnotation.pylist(listType: $listType)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PyListImpl &&
            (identical(other.listType, listType) ||
                other.listType == listType));
  }

  @override
  int get hashCode => Object.hash(runtimeType, listType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PyListImplCopyWith<_$PyListImpl> get copyWith =>
      __$$PyListImplCopyWithImpl<_$PyListImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() pyint,
    required TResult Function() pydouble,
    required TResult Function(List<PyTypeAnnotation> elements) pytuple,
    required TResult Function(PyTypeAnnotation listType) pylist,
    required TResult Function(
            PyTypeAnnotation keyType, PyTypeAnnotation valueType)
        pymap,
  }) {
    return pylist(listType);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? pyint,
    TResult? Function()? pydouble,
    TResult? Function(List<PyTypeAnnotation> elements)? pytuple,
    TResult? Function(PyTypeAnnotation listType)? pylist,
    TResult? Function(PyTypeAnnotation keyType, PyTypeAnnotation valueType)?
        pymap,
  }) {
    return pylist?.call(listType);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? pyint,
    TResult Function()? pydouble,
    TResult Function(List<PyTypeAnnotation> elements)? pytuple,
    TResult Function(PyTypeAnnotation listType)? pylist,
    TResult Function(PyTypeAnnotation keyType, PyTypeAnnotation valueType)?
        pymap,
    required TResult orElse(),
  }) {
    if (pylist != null) {
      return pylist(listType);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PyInt value) pyint,
    required TResult Function(PyDouble value) pydouble,
    required TResult Function(PyTuple value) pytuple,
    required TResult Function(PyList value) pylist,
    required TResult Function(PyMap value) pymap,
  }) {
    return pylist(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PyInt value)? pyint,
    TResult? Function(PyDouble value)? pydouble,
    TResult? Function(PyTuple value)? pytuple,
    TResult? Function(PyList value)? pylist,
    TResult? Function(PyMap value)? pymap,
  }) {
    return pylist?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PyInt value)? pyint,
    TResult Function(PyDouble value)? pydouble,
    TResult Function(PyTuple value)? pytuple,
    TResult Function(PyList value)? pylist,
    TResult Function(PyMap value)? pymap,
    required TResult orElse(),
  }) {
    if (pylist != null) {
      return pylist(this);
    }
    return orElse();
  }
}

abstract class PyList implements PyTypeAnnotation {
  const factory PyList(final PyTypeAnnotation listType) = _$PyListImpl;

  PyTypeAnnotation get listType;
  @JsonKey(ignore: true)
  _$$PyListImplCopyWith<_$PyListImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PyMapImplCopyWith<$Res> {
  factory _$$PyMapImplCopyWith(
          _$PyMapImpl value, $Res Function(_$PyMapImpl) then) =
      __$$PyMapImplCopyWithImpl<$Res>;
  @useResult
  $Res call({PyTypeAnnotation keyType, PyTypeAnnotation valueType});

  $PyTypeAnnotationCopyWith<$Res> get keyType;
  $PyTypeAnnotationCopyWith<$Res> get valueType;
}

/// @nodoc
class __$$PyMapImplCopyWithImpl<$Res>
    extends _$PyTypeAnnotationCopyWithImpl<$Res, _$PyMapImpl>
    implements _$$PyMapImplCopyWith<$Res> {
  __$$PyMapImplCopyWithImpl(
      _$PyMapImpl _value, $Res Function(_$PyMapImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? keyType = null,
    Object? valueType = null,
  }) {
    return _then(_$PyMapImpl(
      null == keyType
          ? _value.keyType
          : keyType // ignore: cast_nullable_to_non_nullable
              as PyTypeAnnotation,
      null == valueType
          ? _value.valueType
          : valueType // ignore: cast_nullable_to_non_nullable
              as PyTypeAnnotation,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $PyTypeAnnotationCopyWith<$Res> get keyType {
    return $PyTypeAnnotationCopyWith<$Res>(_value.keyType, (value) {
      return _then(_value.copyWith(keyType: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $PyTypeAnnotationCopyWith<$Res> get valueType {
    return $PyTypeAnnotationCopyWith<$Res>(_value.valueType, (value) {
      return _then(_value.copyWith(valueType: value));
    });
  }
}

/// @nodoc

class _$PyMapImpl implements PyMap {
  const _$PyMapImpl(this.keyType, this.valueType);

  @override
  final PyTypeAnnotation keyType;
  @override
  final PyTypeAnnotation valueType;

  @override
  String toString() {
    return 'PyTypeAnnotation.pymap(keyType: $keyType, valueType: $valueType)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PyMapImpl &&
            (identical(other.keyType, keyType) || other.keyType == keyType) &&
            (identical(other.valueType, valueType) ||
                other.valueType == valueType));
  }

  @override
  int get hashCode => Object.hash(runtimeType, keyType, valueType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PyMapImplCopyWith<_$PyMapImpl> get copyWith =>
      __$$PyMapImplCopyWithImpl<_$PyMapImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() pyint,
    required TResult Function() pydouble,
    required TResult Function(List<PyTypeAnnotation> elements) pytuple,
    required TResult Function(PyTypeAnnotation listType) pylist,
    required TResult Function(
            PyTypeAnnotation keyType, PyTypeAnnotation valueType)
        pymap,
  }) {
    return pymap(keyType, valueType);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? pyint,
    TResult? Function()? pydouble,
    TResult? Function(List<PyTypeAnnotation> elements)? pytuple,
    TResult? Function(PyTypeAnnotation listType)? pylist,
    TResult? Function(PyTypeAnnotation keyType, PyTypeAnnotation valueType)?
        pymap,
  }) {
    return pymap?.call(keyType, valueType);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? pyint,
    TResult Function()? pydouble,
    TResult Function(List<PyTypeAnnotation> elements)? pytuple,
    TResult Function(PyTypeAnnotation listType)? pylist,
    TResult Function(PyTypeAnnotation keyType, PyTypeAnnotation valueType)?
        pymap,
    required TResult orElse(),
  }) {
    if (pymap != null) {
      return pymap(keyType, valueType);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PyInt value) pyint,
    required TResult Function(PyDouble value) pydouble,
    required TResult Function(PyTuple value) pytuple,
    required TResult Function(PyList value) pylist,
    required TResult Function(PyMap value) pymap,
  }) {
    return pymap(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PyInt value)? pyint,
    TResult? Function(PyDouble value)? pydouble,
    TResult? Function(PyTuple value)? pytuple,
    TResult? Function(PyList value)? pylist,
    TResult? Function(PyMap value)? pymap,
  }) {
    return pymap?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PyInt value)? pyint,
    TResult Function(PyDouble value)? pydouble,
    TResult Function(PyTuple value)? pytuple,
    TResult Function(PyList value)? pylist,
    TResult Function(PyMap value)? pymap,
    required TResult orElse(),
  }) {
    if (pymap != null) {
      return pymap(this);
    }
    return orElse();
  }
}

abstract class PyMap implements PyTypeAnnotation {
  const factory PyMap(
          final PyTypeAnnotation keyType, final PyTypeAnnotation valueType) =
      _$PyMapImpl;

  PyTypeAnnotation get keyType;
  PyTypeAnnotation get valueType;
  @JsonKey(ignore: true)
  _$$PyMapImplCopyWith<_$PyMapImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
